# Memory: 2026-02-05

## Cloud SQL Proxy "Address Already In Use" Root Cause Fix (v224.0)

### Problem
Cloud SQL Proxy crashing on startup with:
```
listen tcp 127.0.0.1:5432: bind: address already in use
```

### Root Causes Identified (3 compounding issues)

#### Root Cause 1: First attempt skips port conflict resolution
The `start()` method only called `_kill_conflicting_processes_async()` on *retries* (`attempt > 0`) or `force_restart`. On the first attempt, when `is_running_async()` returned False (port busy but NOT by our proxy), it jumped straight to spawning the proxy → immediate crash.

#### Root Cause 2: Kill method only targets cloud-sql-proxy processes
`_kill_conflicting_processes_async()` searched for processes by name `cloud-sql-proxy` via pgrep. If port 5432 was held by PostgreSQL or another service, it found zero PIDs and the port stayed occupied.

#### Root Cause 3: No concurrency guard
No Lock prevented multiple callers from racing to start the proxy simultaneously.

### Fixes Applied

#### 1. `_resolve_port_conflict_async()` — New intelligent port resolution
- Uses existing `detect_zombie_state_async()` to diagnose who owns the port
- Healthy proxy → adopt it (update PID file)
- Orphaned proxy → adopt or kill and reclaim
- Non-proxy process → dynamic port fallback (tries ports +1 through +20)
- Last resort → kill conflicting process
- Pre-launch bind test to catch TOCTOU races

#### 2. `start()` now resolves conflicts on EVERY attempt
- Port conflict resolution runs on every attempt, not just retries
- Uses `_start_lock` (asyncio.Lock) to serialize concurrent starts
- Logic extracted to `_start_locked()` for clean lock acquisition

#### 3. Enhanced `_kill_conflicting_processes_async()`
- Phase 1: Kill cloud-sql-proxy processes (SIGTERM, 2s grace, SIGKILL)
- Phase 2: If port still held, identify actual PID via lsof and kill it
- Proper SIGTERM → grace period → SIGKILL escalation (was 0.5s, now 3s)

#### 4. Dynamic port fallback
- `_find_available_port_async()` scans ports near configured port
- `_test_port_bindable()` does actual bind test (not just lsof check)
- `effective_port` property tracks actual port in use
- Environment variable `Ironcliw_DB_PORT` updated for downstream consumers

#### 5. Cross-repo integration
- `unified_supervisor.py`: Propagates `effective_port` to environment
- `cloud_database_adapter.py`: Fixed to use singleton `get_proxy_manager()` instead of creating new instances
- `cloud_sql_connection_manager.py`: Already uses singleton + Ironcliw_DB_PORT

### Files Changed
- `backend/intelligence/cloud_sql_proxy_manager.py` (v224.0)
- `unified_supervisor.py`
- `backend/intelligence/cloud_database_adapter.py`
