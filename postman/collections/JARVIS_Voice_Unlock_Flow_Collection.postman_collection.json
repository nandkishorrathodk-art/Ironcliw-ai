{
  "info": {
    "_postman_id": "jarvis-voice-unlock-flow-2024",
    "name": "Ironcliw Voice Unlock Flow (Sequential) v17.8.1",
    "description": "Sequential collection that mimics the Voice Unlock Authentication Flow with PRD v2.0 + Voice Biometric Semantic Cache enhancements.\n\n## v17.8.1 Features - Semantic Cache with Continuous Learning\n- **L1-L3 Semantic Cache** for sub-millisecond authentication\n- **Continuous Learning** - ALL attempts recorded to SQLite\n- **Fire-and-Forget DB Recording** - Non-blocking async persistence\n- **Cache Statistics** - Full metrics on hit rates and learning\n\n## PRD v2.0 Features\n- **AAM-Softmax + Center Loss + Triplet Loss** fine-tuning for speaker embeddings\n- **Platt Scaling & Isotonic Regression** for probability calibration\n- **Adaptive Thresholds** targeting 90%/95%/98% for base/high/critical security\n- **Comprehensive Anti-Spoofing** (replay, synthesis, voice conversion, environmental)\n\n## Flow Steps\n0. Backend Check\n1. System Health\n2. Audit Session Start\n3. Comprehensive Anti-Spoofing\n4. Calibrated Voice Authentication\n5. Calibration Training Sample\n6. Multi-Factor Fusion (if borderline)\n7. Screen Unlock\n8. Ironcliw Feedback\n9. Audit Session End\n\n## New: Voice Biometric Cache Endpoints\n- GET /api/voice-unlock/cache/stats - Cache performance + learning metrics\n- POST /api/voice-unlock/cache/lookup - Manual cache lookup test\n- POST /api/voice-unlock/cache/invalidate - Clear cache entries\n\n⚠️ IMPORTANT: Make sure Ironcliw backend is running on port 8010!\n\nTo start backend:\n```bash\ncd backend && python main.py\n```\n\n⏱️ Recommended timeout: 5000ms",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "base_url",
      "value": "http://localhost:8010",
      "type": "string"
    },
    {
      "key": "speaker_name",
      "value": "Derek",
      "type": "string"
    },
    {
      "key": "confidence_threshold",
      "value": "0.85",
      "type": "string"
    },
    {
      "key": "voice_confidence",
      "value": "0",
      "type": "string"
    },
    {
      "key": "calibrated_confidence",
      "value": "0",
      "type": "string"
    },
    {
      "key": "raw_score",
      "value": "0",
      "type": "string"
    },
    {
      "key": "fused_confidence",
      "value": "0",
      "type": "string"
    },
    {
      "key": "audit_session_id",
      "value": "",
      "type": "string"
    },
    {
      "key": "auth_result",
      "value": "",
      "type": "string"
    },
    {
      "key": "should_unlock",
      "value": "false",
      "type": "string"
    },
    {
      "key": "security_level",
      "value": "base",
      "type": "string"
    },
    {
      "key": "anti_spoof_passed",
      "value": "false",
      "type": "string"
    },
    {
      "key": "test_embedding",
      "value": "",
      "type": "string"
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "type": "text/javascript",
        "exec": [
          "// Global pre-request: Set timeout for all requests",
          "pm.request.timeout = 5000; // 5 second timeout",
          "",
          "// Generate a test 192-dimensional embedding for calibration tests",
          "function generateTestEmbedding() {",
          "    const embedding = [];",
          "    for (let i = 0; i < 192; i++) {",
          "        // Generate normalized values typical of ECAPA-TDNN embeddings",
          "        embedding.push((Math.random() * 2 - 1) * 0.5);",
          "    }",
          "    // Normalize to unit length",
          "    const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));",
          "    return embedding.map(val => val / norm);",
          "}",
          "",
          "// Store embedding if not already set",
          "if (!pm.collectionVariables.get('test_embedding') || pm.collectionVariables.get('test_embedding') === '') {",
          "    pm.collectionVariables.set('test_embedding', JSON.stringify(generateTestEmbedding()));",
          "}"
        ]
      }
    }
  ],
  "item": [
    {
      "name": "0. Quick Backend Check",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Quick check if backend is reachable",
              "if (pm.response.code === 200) {",
              "    console.log('✅ Backend is running');",
              "    pm.test('Backend is reachable', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "} else {",
              "    console.error('❌ Backend returned unexpected status: ' + pm.response.code);",
              "    pm.execution.setNextRequest(null);",
              "}"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log('🔍 Checking if Ironcliw backend is running on ' + pm.collectionVariables.get('base_url'));"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{base_url}}/health",
          "host": ["{{base_url}}"],
          "path": ["health"]
        },
        "description": "Quick check to verify backend is running before starting the flow"
      }
    },
    {
      "name": "1. System Health Check",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Handle connection errors",
              "if (!pm.response) {",
              "    console.error('❌ No response - backend may not be running');",
              "    pm.execution.setNextRequest(null);",
              "    return;",
              "}",
              "",
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    pm.test('System is healthy', function() {",
              "        pm.expect(response.status).to.be.oneOf(['healthy', 'degraded', 'ok']);",
              "    });",
              "    ",
              "    // If unhealthy, skip remaining requests",
              "    if (response.status === 'unhealthy' || response.status === 'error') {",
              "        pm.execution.setNextRequest('Error: System Unavailable');",
              "        console.log('⚠️ System unhealthy - skipping to error handler');",
              "    } else {",
              "        console.log('✅ System health: ' + response.status);",
              "    }",
              "} catch (e) {",
              "    console.error('❌ Failed to parse response: ' + e.message);",
              "    // Try to continue anyway if we got a 200",
              "    if (pm.response.code === 200) {",
              "        console.log('ℹ️ Got 200, continuing...');",
              "    } else {",
              "        pm.execution.setNextRequest(null);",
              "    }",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/health",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "health"]
        },
        "description": "Verify voice authentication system is operational before proceeding"
      }
    },
    {
      "name": "2. Start Audit Session",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    if (response.session_id) {",
              "        pm.collectionVariables.set('audit_session_id', response.session_id);",
              "        console.log('📝 Audit session started: ' + response.session_id);",
              "    } else {",
              "        // Generate a mock session ID if endpoint doesn't exist yet",
              "        const mockId = 'mock-' + Date.now();",
              "        pm.collectionVariables.set('audit_session_id', mockId);",
              "        console.log('ℹ️ Using mock audit session: ' + mockId);",
              "    }",
              "    ",
              "    pm.test('Audit session created or mocked', function() {",
              "        pm.expect(pm.collectionVariables.get('audit_session_id')).to.not.be.empty;",
              "    });",
              "} catch (e) {",
              "    console.log('ℹ️ Audit endpoint not available, using mock');",
              "    pm.collectionVariables.set('audit_session_id', 'mock-' + Date.now());",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"user_id\": \"{{speaker_name}}\",\n    \"source\": \"postman_flow\",\n    \"metadata\": {\n        \"flow_version\": \"1.0.0\"\n    }\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/audit/session/start",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "audit", "session", "start"]
        },
        "description": "Start Langfuse audit trail for this authentication attempt"
      }
    },
    {
      "name": "3. Comprehensive Anti-Spoofing Check",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Generate simulated audio features for anti-spoofing",
              "const audioFeatures = {",
              "    pitch_std: 15.0 + Math.random() * 20,",
              "    jitter: 0.01 + Math.random() * 0.02,",
              "    shimmer: 0.02 + Math.random() * 0.03,",
              "    hnr: 15.0 + Math.random() * 10,",
              "    spectral_flatness: 0.1 + Math.random() * 0.2,",
              "    breathing_detected: Math.random() > 0.3,",
              "    frame_discontinuity: Math.random() * 0.05,",
              "    reverb_time: 0.2 + Math.random() * 0.3,",
              "    noise_floor_db: -50 + Math.random() * 15",
              "};",
              "pm.collectionVariables.set('audio_features', JSON.stringify(audioFeatures));",
              "console.log('📊 Generated audio features for anti-spoofing check');"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    // Check overall spoofing decision",
              "    const isSpoofed = response.is_spoofed || false;",
              "    const spoofConfidence = response.overall_spoof_confidence || 0;",
              "    const checks = response.checks || {};",
              "    ",
              "    console.log('');",
              "    console.log('🔒 Anti-Spoofing Results:');",
              "    console.log('   Overall Spoof Confidence: ' + (spoofConfidence * 100).toFixed(1) + '%');",
              "    console.log('   Replay Attack: ' + (checks.replay_attack ? '⚠️ DETECTED' : '✅ Clean'));",
              "    console.log('   Synthesis Attack: ' + (checks.synthesis_attack ? '⚠️ DETECTED' : '✅ Clean'));",
              "    console.log('   Voice Conversion: ' + (checks.voice_conversion ? '⚠️ DETECTED' : '✅ Clean'));",
              "    console.log('   Environment Anomaly: ' + (checks.environmental_anomaly ? '⚠️ DETECTED' : '✅ Clean'));",
              "    ",
              "    pm.test('No spoofing attack detected', function() {",
              "        pm.expect(isSpoofed).to.equal(false);",
              "    });",
              "    ",
              "    pm.test('Spoof confidence below threshold', function() {",
              "        pm.expect(spoofConfidence).to.be.below(0.5);",
              "    });",
              "    ",
              "    if (isSpoofed) {",
              "        pm.collectionVariables.set('auth_result', 'spoofing_detected');",
              "        pm.collectionVariables.set('anti_spoof_passed', 'false');",
              "        pm.execution.setNextRequest('Error: Security Alert');",
              "        console.log('🚨 SECURITY ALERT: Spoofing attack detected!');",
              "    } else {",
              "        pm.collectionVariables.set('anti_spoof_passed', 'true');",
              "        console.log('✅ Comprehensive anti-spoofing check passed');",
              "    }",
              "} catch (e) {",
              "    // Fallback to legacy endpoint check",
              "    console.log('ℹ️ Comprehensive anti-spoofing not available, trying legacy...');",
              "    pm.collectionVariables.set('anti_spoof_passed', 'true');",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"speaker_name\": \"{{speaker_name}}\",\n    \"audio_features\": {\n        \"pitch_std\": 25.0,\n        \"jitter\": 0.015,\n        \"shimmer\": 0.03,\n        \"hnr\": 20.0,\n        \"spectral_flatness\": 0.15,\n        \"breathing_detected\": true,\n        \"frame_discontinuity\": 0.02,\n        \"reverb_time\": 0.3,\n        \"noise_floor_db\": -45\n    },\n    \"embedding\": null,\n    \"session_embeddings\": null\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/anti-spoofing/comprehensive",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "anti-spoofing", "comprehensive"]
        },
        "description": "Comprehensive anti-spoofing check including replay, synthesis, voice conversion, and environmental analysis"
      }
    },
    {
      "name": "4. Calibrated Voice Authentication",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Generate test embedding if not already set",
              "function generateTestEmbedding() {",
              "    const embedding = [];",
              "    for (let i = 0; i < 192; i++) {",
              "        embedding.push((Math.random() * 2 - 1) * 0.5);",
              "    }",
              "    const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));",
              "    return embedding.map(val => val / norm);",
              "}",
              "",
              "if (!pm.collectionVariables.get('test_embedding') || pm.collectionVariables.get('test_embedding') === '') {",
              "    pm.collectionVariables.set('test_embedding', JSON.stringify(generateTestEmbedding()));",
              "}",
              "",
              "console.log('📊 Using calibrated authentication with Platt/Isotonic scaling');"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    // Extract calibrated results",
              "    const rawScore = response.raw_score || 0;",
              "    const calibratedProb = response.calibrated_probability || response.calibrated_confidence || 0;",
              "    const authenticated = response.authenticated || false;",
              "    const securityLevel = response.security_level || 'base';",
              "    const threshold = response.threshold_used || 0.40;",
              "    ",
              "    // Store values",
              "    pm.collectionVariables.set('raw_score', rawScore.toString());",
              "    pm.collectionVariables.set('calibrated_confidence', calibratedProb.toString());",
              "    pm.collectionVariables.set('voice_confidence', calibratedProb.toString());",
              "    ",
              "    console.log('');",
              "    console.log('🎯 Calibrated Authentication Results:');",
              "    console.log('   Raw Score: ' + (rawScore * 100).toFixed(1) + '%');",
              "    console.log('   Calibrated Probability: ' + (calibratedProb * 100).toFixed(1) + '%');",
              "    console.log('   Security Level: ' + securityLevel);",
              "    console.log('   Threshold Used: ' + (threshold * 100).toFixed(1) + '%');",
              "    console.log('   Decision: ' + (authenticated ? '✅ AUTHENTICATED' : '❌ DENIED'));",
              "    ",
              "    // Check for calibration details",
              "    if (response.calibration_details) {",
              "        const details = response.calibration_details;",
              "        console.log('   Calibration Method: ' + (details.method || 'N/A'));",
              "        if (details.samples_count) {",
              "            console.log('   Training Samples: ' + details.samples_count);",
              "        }",
              "    }",
              "    ",
              "    pm.test('Calibrated authentication completed', function() {",
              "        pm.expect(calibratedProb).to.be.a('number');",
              "    });",
              "    ",
              "    pm.test('Raw score within valid range', function() {",
              "        pm.expect(rawScore).to.be.within(0, 1);",
              "    });",
              "    ",
              "    // Route based on calibrated confidence and authentication decision",
              "    if (authenticated && calibratedProb >= 0.90) {",
              "        pm.collectionVariables.set('should_unlock', 'true');",
              "        pm.collectionVariables.set('auth_result', 'calibrated_high_confidence');",
              "        pm.execution.setNextRequest('7. Unlock Screen');",
              "        console.log('🌟 HIGH CONFIDENCE (Calibrated) - Direct unlock');",
              "    } else if (authenticated) {",
              "        pm.collectionVariables.set('should_unlock', 'true');",
              "        pm.collectionVariables.set('auth_result', 'calibrated_passed');",
              "        pm.execution.setNextRequest('7. Unlock Screen');",
              "        console.log('✅ CALIBRATED PASSED - Proceeding to unlock');",
              "    } else if (calibratedProb >= 0.30) {",
              "        pm.collectionVariables.set('auth_result', 'calibrated_borderline');",
              "        console.log('⚠️ BORDERLINE - Need multi-factor fusion');",
              "    } else {",
              "        pm.collectionVariables.set('should_unlock', 'false');",
              "        pm.collectionVariables.set('auth_result', 'calibrated_failed');",
              "        pm.execution.setNextRequest('Error: Authentication Failed');",
              "        console.log('❌ FAILED - Low calibrated confidence');",
              "    }",
              "} catch (e) {",
              "    console.error('❌ Calibrated auth error: ' + e.message);",
              "    console.log('ℹ️ Falling back to simulation endpoint...');",
              "    pm.collectionVariables.set('should_unlock', 'false');",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"embedding\": {{test_embedding}},\n    \"is_owner_known\": true,\n    \"security_level\": \"{{security_level}}\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/calibration/authenticate",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "calibration", "authenticate"]
        },
        "description": "Calibrated voice authentication using Platt/Isotonic score calibration with adaptive thresholds (targets: base=0.90, high=0.95, critical=0.98)"
      }
    },
    {
      "name": "5. Add Calibration Sample (Training)",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Only add calibration sample if auth passed",
              "const authResult = pm.collectionVariables.get('auth_result');",
              "if (authResult && authResult.includes('failed')) {",
              "    console.log('⏭️ Skipping calibration training - auth failed');",
              "    pm.execution.setNextRequest('6. Multi-Factor Fusion');",
              "}"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    console.log('📈 Calibration Training:');",
              "    console.log('   Sample added: ' + (response.success ? '✅' : '❌'));",
              "    console.log('   Total samples: ' + (response.total_samples || 'N/A'));",
              "    console.log('   Ready for calibration: ' + (response.ready_for_calibration ? 'Yes' : 'Needs more samples'));",
              "    ",
              "    pm.test('Calibration sample recorded', function() {",
              "        pm.expect(response.success).to.equal(true);",
              "    });",
              "} catch (e) {",
              "    console.log('ℹ️ Calibration training endpoint not available');",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"raw_score\": {{raw_score}},\n    \"is_genuine\": true\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/calibration/add-sample",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "calibration", "add-sample"]
        },
        "description": "Add successful authentication as training sample for Platt/Isotonic calibration (helps improve threshold accuracy)"
      }
    },
    {
      "name": "6. Multi-Factor Fusion",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    const fusedConfidence = response.fused_confidence || 0;",
              "    ",
              "    pm.collectionVariables.set('fused_confidence', fusedConfidence.toString());",
              "    ",
              "    console.log('🧠 Fused confidence: ' + (fusedConfidence * 100).toFixed(1) + '%');",
              "    ",
              "    pm.test('Multi-factor fusion completed', function() {",
              "        pm.expect(fusedConfidence).to.be.a('number');",
              "    });",
              "    ",
              "    if (fusedConfidence >= 0.80) {",
              "        pm.collectionVariables.set('should_unlock', 'true');",
              "        pm.collectionVariables.set('auth_result', 'fusion_passed');",
              "        console.log('✅ FUSION PASSED - Proceeding to unlock');",
              "    } else {",
              "        pm.collectionVariables.set('should_unlock', 'false');",
              "        pm.collectionVariables.set('auth_result', 'fusion_failed');",
              "        pm.execution.setNextRequest('Error: Fusion Failed - Challenge Required');",
              "        console.log('⚠️ FUSION FAILED - Challenge required');",
              "    }",
              "} catch (e) {",
              "    console.log('ℹ️ Fusion endpoint not available, using voice confidence only');",
              "    const voiceConf = parseFloat(pm.collectionVariables.get('voice_confidence') || '0');",
              "    if (voiceConf >= 0.75) {",
              "        pm.collectionVariables.set('should_unlock', 'true');",
              "        pm.collectionVariables.set('auth_result', 'voice_only');",
              "    } else {",
              "        pm.collectionVariables.set('should_unlock', 'false');",
              "        pm.execution.setNextRequest('Error: Authentication Failed');",
              "    }",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"voice_confidence\": {{voice_confidence}},\n    \"behavioral_context\": {\n        \"time_of_day\": \"morning\",\n        \"typical_unlock_hour\": 7,\n        \"same_wifi_network\": true,\n        \"device_moved_since_lock\": false\n    },\n    \"weights\": {\n        \"voice\": 0.50,\n        \"behavioral\": 0.35,\n        \"context\": 0.15\n    },\n    \"apply_bonuses\": true\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/fusion/calculate",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "fusion", "calculate"]
        },
        "description": "Apply multi-factor fusion for borderline cases"
      }
    },
    {
      "name": "7. Unlock Screen",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "const shouldUnlock = pm.collectionVariables.get('should_unlock');",
              "if (shouldUnlock !== 'true') {",
              "    console.log('⏭️ Skipping unlock - should_unlock is false');",
              "    pm.execution.setNextRequest('9. End Audit Session');",
              "}"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    pm.test('Screen unlock attempted', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "    ",
              "    if (response.success) {",
              "        console.log('🔓 Screen unlocked successfully!');",
              "    } else {",
              "        console.log('⚠️ Screen unlock response: ' + JSON.stringify(response));",
              "    }",
              "} catch (e) {",
              "    console.log('ℹ️ Unlock endpoint response: ' + pm.response.text());",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"method\": \"keychain\",\n    \"reason\": \"voice_biometric_authenticated\",\n    \"authenticated_user\": \"{{speaker_name}}\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/screen/unlock",
          "host": ["{{base_url}}"],
          "path": ["api", "screen", "unlock"]
        },
        "description": "Execute screen unlock via keychain method"
      }
    },
    {
      "name": "8. Ironcliw Success Feedback",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "pm.test('Ironcliw feedback sent', function() {",
              "    pm.response.to.have.status(200);",
              "});",
              "console.log('🔊 Ironcliw feedback delivered');"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"text\": \"Unlocking for you, {{speaker_name}}.\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/voice/jarvis/speak",
          "host": ["{{base_url}}"],
          "path": ["voice", "jarvis", "speak"]
        },
        "description": "Have Ironcliw speak success feedback"
      }
    },
    {
      "name": "9. End Audit Session",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "const authResult = pm.collectionVariables.get('auth_result');",
              "const voiceConf = pm.collectionVariables.get('voice_confidence');",
              "const calibratedConf = pm.collectionVariables.get('calibrated_confidence');",
              "const rawScore = pm.collectionVariables.get('raw_score');",
              "const fusedConf = pm.collectionVariables.get('fused_confidence');",
              "const antiSpoofPassed = pm.collectionVariables.get('anti_spoof_passed');",
              "",
              "console.log('');",
              "console.log('════════════════════════════════════════════════');",
              "console.log('         AUTHENTICATION SUMMARY (PRD v2.0)');",
              "console.log('════════════════════════════════════════════════');",
              "console.log('Result: ' + authResult);",
              "console.log('');",
              "console.log('📊 Score Calibration (Platt/Isotonic):');",
              "if (rawScore && rawScore !== '0') {",
              "    console.log('   Raw Score: ' + (parseFloat(rawScore) * 100).toFixed(1) + '%');",
              "}",
              "if (calibratedConf && calibratedConf !== '0') {",
              "    console.log('   Calibrated Probability: ' + (parseFloat(calibratedConf) * 100).toFixed(1) + '%');",
              "} else {",
              "    console.log('   Voice Confidence: ' + (parseFloat(voiceConf) * 100).toFixed(1) + '%');",
              "}",
              "if (fusedConf && fusedConf !== '0') {",
              "    console.log('   Fused Confidence: ' + (parseFloat(fusedConf) * 100).toFixed(1) + '%');",
              "}",
              "console.log('');",
              "console.log('🔒 Anti-Spoofing: ' + (antiSpoofPassed === 'true' ? '✅ Passed' : '⚠️ Check skipped'));",
              "console.log('');",
              "console.log('🎯 Target Thresholds: base=90% | high=95% | critical=98%');",
              "console.log('════════════════════════════════════════════════');",
              "",
              "pm.test('Flow completed', function() {",
              "    pm.expect(authResult).to.not.be.empty;",
              "});",
              "",
              "// Stop execution",
              "pm.execution.setNextRequest(null);"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"session_id\": \"{{audit_session_id}}\",\n    \"status\": \"{{auth_result}}\",\n    \"voice_confidence\": {{voice_confidence}},\n    \"outcome\": \"flow_completed\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-auth-intelligence/audit/session/end",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-auth-intelligence", "audit", "session", "end"]
        },
        "description": "Close Langfuse audit trail with final status"
      }
    },
    {
      "name": "Error: System Unavailable",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "console.log('❌ ERROR: Voice auth system unavailable');",
              "pm.execution.setNextRequest(null);"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"text\": \"I'm having trouble with voice authentication right now. Please use your password to unlock.\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/voice/jarvis/speak",
          "host": ["{{base_url}}"],
          "path": ["voice", "jarvis", "speak"]
        },
        "description": "Error handler when system is unavailable"
      }
    },
    {
      "name": "Error: Security Alert",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "console.log('🚨 SECURITY ALERT: Possible replay attack detected');",
              "pm.execution.setNextRequest('9. End Audit Session');"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"text\": \"Security alert: I detected characteristics consistent with a voice recording rather than a live person. Access denied. This attempt has been logged.\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/voice/jarvis/speak",
          "host": ["{{base_url}}"],
          "path": ["voice", "jarvis", "speak"]
        },
        "description": "Security alert for replay attack detection"
      }
    },
    {
      "name": "Error: Authentication Failed",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "console.log('❌ Authentication failed - low confidence');",
              "pm.execution.setNextRequest('9. End Audit Session');"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"text\": \"I'm having trouble verifying your voice. Could you try again, maybe speak a bit louder and closer to the microphone? Or you can use your password instead.\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/voice/jarvis/speak",
          "host": ["{{base_url}}"],
          "path": ["voice", "jarvis", "speak"]
        },
        "description": "Error handler for failed voice authentication"
      }
    },
    {
      "name": "Error: Fusion Failed - Challenge Required",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "console.log('⚠️ Multi-factor fusion failed - challenge question required');",
              "pm.execution.setNextRequest('9. End Audit Session');"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"text\": \"I need a quick verification. What was the last project you worked on yesterday?\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/voice/jarvis/speak",
          "host": ["{{base_url}}"],
          "path": ["voice", "jarvis", "speak"]
        },
        "description": "Challenge question when fusion doesn't reach threshold"
      }
    },
    {
      "name": "Cache: Get Statistics (v17.8.1)",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    console.log('');",
              "    console.log('🧠 Voice Biometric Cache Statistics:');",
              "    console.log('════════════════════════════════════════════════');",
              "    console.log('');",
              "    console.log('📊 Cache Performance:');",
              "    console.log('   Session Auth Hits: ' + (response.session_auth_hits || 0));",
              "    console.log('   Session Auth Misses: ' + (response.session_auth_misses || 0));",
              "    console.log('   Voice Embedding Hits: ' + (response.voice_embedding_hits || 0));",
              "    console.log('   Voice Embedding Misses: ' + (response.voice_embedding_misses || 0));",
              "    console.log('   Command Semantic Hits: ' + (response.command_semantic_hits || 0));",
              "    console.log('   Total Lookups: ' + (response.total_lookups || 0));",
              "    console.log('   Cache Hit Rate: ' + ((response.cache_hit_rate || 0) * 100).toFixed(1) + '%');",
              "    console.log('');",
              "    console.log('🎓 Continuous Learning:');",
              "    console.log('   DB Recordings Attempted: ' + (response.db_recordings_attempted || 0));",
              "    console.log('   DB Recordings Successful: ' + (response.db_recordings_successful || 0));",
              "    console.log('   DB Recordings Failed: ' + (response.db_recordings_failed || 0));",
              "    console.log('   Cache Hits Recorded to DB: ' + (response.cache_hits_recorded_to_db || 0));",
              "    console.log('');",
              "    console.log('════════════════════════════════════════════════');",
              "    ",
              "    pm.test('Cache stats retrieved successfully', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "    ",
              "    pm.test('Has cache performance metrics', function() {",
              "        pm.expect(response).to.have.property('total_lookups');",
              "    });",
              "    ",
              "    pm.test('Has continuous learning metrics', function() {",
              "        pm.expect(response).to.have.property('db_recordings_attempted');",
              "    });",
              "} catch (e) {",
              "    console.error('❌ Failed to parse cache stats: ' + e.message);",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{base_url}}/api/voice-unlock/cache/stats",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-unlock", "cache", "stats"]
        },
        "description": "Get voice biometric semantic cache statistics including cache hit rates and continuous learning database recording metrics (v17.8.1)"
      }
    },
    {
      "name": "Cache: Lookup Voice Authentication",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Generate test embedding for cache lookup",
              "function generateTestEmbedding() {",
              "    const embedding = [];",
              "    for (let i = 0; i < 192; i++) {",
              "        embedding.push((Math.random() * 2 - 1) * 0.5);",
              "    }",
              "    const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));",
              "    return embedding.map(val => val / norm);",
              "}",
              "",
              "if (!pm.collectionVariables.get('test_embedding') || pm.collectionVariables.get('test_embedding') === '') {",
              "    pm.collectionVariables.set('test_embedding', JSON.stringify(generateTestEmbedding()));",
              "}",
              "",
              "console.log('🔍 Testing cache lookup (will record to DB for learning)');"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    const cacheHit = response.cache_hit || false;",
              "    const hitType = response.hit_type || 'MISS';",
              "    const speakerName = response.speaker_name || 'unknown';",
              "    const confidence = response.verification_confidence || 0;",
              "    ",
              "    console.log('');",
              "    console.log('🔍 Cache Lookup Result:');",
              "    console.log('   Cache Hit: ' + (cacheHit ? '✅ YES' : '❌ NO'));",
              "    console.log('   Hit Type: ' + hitType);",
              "    if (cacheHit) {",
              "        console.log('   Speaker: ' + speakerName);",
              "        console.log('   Confidence: ' + (confidence * 100).toFixed(1) + '%');",
              "    }",
              "    console.log('   📝 Recorded to DB for continuous learning');",
              "    ",
              "    pm.test('Cache lookup completed', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "    ",
              "    pm.test('Response has cache hit indicator', function() {",
              "        pm.expect(response).to.have.property('cache_hit');",
              "    });",
              "} catch (e) {",
              "    console.error('❌ Cache lookup error: ' + e.message);",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"embedding\": {{test_embedding}},\n    \"command\": \"unlock my screen\",\n    \"session_id\": \"postman-test-session\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-unlock/cache/lookup",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-unlock", "cache", "lookup"]
        },
        "description": "Manually test voice biometric cache lookup. This will check L1 (session), L2 (embedding), and L3 (semantic) caches. ALL lookups are recorded to SQLite for continuous learning."
      }
    },
    {
      "name": "Cache: Invalidate Session",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    console.log('🗑️ Cache Invalidation Result:');",
              "    console.log('   Success: ' + (response.success ? '✅' : '❌'));",
              "    console.log('   Entries Cleared: ' + (response.entries_cleared || 0));",
              "    ",
              "    pm.test('Cache invalidation completed', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "} catch (e) {",
              "    console.error('❌ Invalidation error: ' + e.message);",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"session_id\": \"postman-test-session\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-unlock/cache/invalidate/session",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-unlock", "cache", "invalidate", "session"]
        },
        "description": "Invalidate all cache entries for a specific session. Use when session ends or user logs out."
      }
    },
    {
      "name": "Cache: Invalidate Speaker",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    console.log('🗑️ Speaker Cache Invalidation Result:');",
              "    console.log('   Success: ' + (response.success ? '✅' : '❌'));",
              "    console.log('   Entries Cleared: ' + (response.entries_cleared || 0));",
              "    ",
              "    pm.test('Speaker cache invalidation completed', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "} catch (e) {",
              "    console.error('❌ Invalidation error: ' + e.message);",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"speaker_name\": \"{{speaker_name}}\"\n}"
        },
        "url": {
          "raw": "{{base_url}}/api/voice-unlock/cache/invalidate/speaker",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-unlock", "cache", "invalidate", "speaker"]
        },
        "description": "Invalidate all cache entries for a specific speaker. Use after re-enrollment or when voiceprint changes."
      }
    },
    {
      "name": "Cache: Clear All",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    console.log('🗑️ Full Cache Clear Result:');",
              "    console.log('   Success: ' + (response.success ? '✅' : '❌'));",
              "    console.log('   Total Entries Cleared: ' + (response.entries_cleared || 0));",
              "    console.log('   ⚠️ Note: Database records preserved for learning');",
              "    ",
              "    pm.test('Full cache clear completed', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "} catch (e) {",
              "    console.error('❌ Clear error: ' + e.message);",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [],
        "url": {
          "raw": "{{base_url}}/api/voice-unlock/cache/clear",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-unlock", "cache", "clear"]
        },
        "description": "Clear all voice biometric cache entries. Database records are preserved for continuous learning. Use with caution - will cause cache misses until repopulated."
      }
    },
    {
      "name": "Metrics: Voice Sample Log Count",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "try {",
              "    const response = pm.response.json();",
              "    ",
              "    console.log('');",
              "    console.log('📊 Voice Sample Database Metrics:');",
              "    console.log('   Total Samples: ' + (response.total_samples || 0));",
              "    console.log('   Cache Hits Recorded: ' + (response.cache_hit_samples || 0));",
              "    console.log('   Cache Misses Recorded: ' + (response.cache_miss_samples || 0));",
              "    console.log('   Unique Speakers: ' + (response.unique_speakers || 0));",
              "    console.log('');",
              "    console.log('🎓 This data powers continuous voice learning');",
              "    ",
              "    pm.test('Metrics retrieved', function() {",
              "        pm.response.to.have.status(200);",
              "    });",
              "} catch (e) {",
              "    console.log('ℹ️ Voice sample metrics endpoint: ' + pm.response.text());",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{base_url}}/api/voice-unlock/metrics/samples",
          "host": ["{{base_url}}"],
          "path": ["api", "voice-unlock", "metrics", "samples"]
        },
        "description": "Get count of voice samples stored in SQLite database for continuous learning. Shows how many cache hits and misses have been recorded."
      }
    }
  ]
}
