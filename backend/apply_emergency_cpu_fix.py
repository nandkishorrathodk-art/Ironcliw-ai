#!/usr/bin/env python3
"""
Apply emergency CPU fix to Ironcliw immediately
Run this to reduce CPU from 97% to ~40% without Rust
"""

import os
import sys
import time
import psutil
import subprocess

# Add backend to path
backend_path = os.path.dirname(os.path.abspath(__file__))
if backend_path not in sys.path:
    sys.path.insert(0, backend_path)

def kill_high_cpu_processes():
    """Kill any Python processes using high CPU"""
    print("🔍 Searching for high CPU processes...")
    
    killed = 0
    current_pid = os.getpid()
    
    for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cpu_percent']):
        try:
            if proc.info['name'] in ['python', 'python3', 'python3.10']:
                # Check if it's a Ironcliw process
                cmdline = ' '.join(proc.info.get('cmdline', []))
                if 'main.py' in cmdline and proc.info['pid'] != current_pid:
                    cpu = proc.cpu_percent(interval=0.5)
                    if cpu > 50:
                        print(f"   Killing PID {proc.info['pid']} using {cpu:.1f}% CPU")
                        proc.kill()
                        killed += 1
        except:
            pass
    
    if killed:
        print(f"✅ Killed {killed} high-CPU processes")
        time.sleep(2)
    else:
        print("   No high-CPU processes found")
    
    return killed

def apply_immediate_fixes():
    """Apply immediate configuration fixes"""
    print("\n⚡ Applying immediate fixes...")
    
    # Create emergency config
    config = {
        'DISABLE_CONTINUOUS_LEARNING': 'false',  # Keep enabled but throttled
        'LEARNING_CPU_LIMIT': '30',
        'LEARNING_MEMORY_LIMIT': '25',
        'LEARNING_THROTTLE_FACTOR': '5.0',
        'VISION_PROCESSING_THREADS': '2',
        'MAX_PARALLEL_OPERATIONS': '2',
        'ENABLE_EMERGENCY_THROTTLE': 'true',
        'OMP_NUM_THREADS': '2',
        'MKL_NUM_THREADS': '2',
        'NUMEXPR_NUM_THREADS': '2',
    }
    
    # Write config to .env file
    env_file = os.path.join(backend_path, '.env')
    
    # Read existing .env
    existing = {}
    if os.path.exists(env_file):
        with open(env_file, 'r') as f:
            for line in f:
                if '=' in line and not line.startswith('#'):
                    key, value = line.strip().split('=', 1)
                    existing[key] = value
    
    # Update with emergency config
    existing.update(config)
    
    # Write back
    with open(env_file, 'w') as f:
        f.write("# Ironcliw Emergency CPU Configuration\n")
        f.write("# Generated by apply_emergency_cpu_fix.py\n\n")
        for key, value in existing.items():
            f.write(f"{key}={value}\n")
    
    print("✅ Updated .env with CPU limits")
    
    # Apply to current environment
    for key, value in config.items():
        os.environ[key] = value
    
    print("✅ Applied environment limits")

def patch_learning_module():
    """Patch the learning module to use emergency throttling"""
    print("\n🔧 Patching learning module...")
    
    try:
        # Import and patch
        from vision.emergency_cpu_fix import apply_emergency_fixes, ThrottledContinuousLearning
        from vision import advanced_continuous_learning
        
        # Apply emergency fixes
        emergency_fix = apply_emergency_fixes()
        
        # Patch the get function
        original_get = advanced_continuous_learning.get_advanced_continuous_learning
        
        def throttled_get(model):
            learning = original_get(model)
            return ThrottledContinuousLearning(learning)
        
        advanced_continuous_learning.get_advanced_continuous_learning = throttled_get
        
        print("✅ Patched continuous learning with throttling")
        return True
        
    except Exception as e:
        print(f"⚠️  Could not patch learning module: {e}")
        return False

def restart_with_limits():
    """Restart Ironcliw with CPU limits"""
    print("\n🔄 Restarting Ironcliw with CPU limits...")
    
    # Kill existing
    subprocess.run(['pkill', '-f', 'python.*main.py'], capture_output=True)
    time.sleep(2)
    
    # Start with nice level and CPU affinity
    cmd = [
        'nice', '-n', '10',  # Lower priority
        sys.executable, 'main.py', '--port', '8000'
    ]
    
    # Start in background
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=os.environ.copy()
    )
    
    print(f"✅ Started Ironcliw with PID {process.pid}")
    
    # Monitor startup
    print("\n📊 Monitoring CPU usage...")
    for i in range(10):
        time.sleep(1)
        try:
            proc = psutil.Process(process.pid)
            cpu = proc.cpu_percent(interval=0.5)
            mem = proc.memory_info().rss / 1024 / 1024
            print(f"   {i+1}s: CPU: {cpu:.1f}% | Memory: {mem:.0f}MB")
        except:
            break
    
    return process

def monitor_performance(duration=30):
    """Monitor performance after fixes"""
    print(f"\n📈 Monitoring performance for {duration} seconds...")
    
    cpu_samples = []
    mem_samples = []
    
    for i in range(duration):
        # Find main.py process
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                cmdline = ' '.join(proc.info.get('cmdline', []))
                if 'main.py' in cmdline and '8000' in cmdline:
                    cpu = proc.cpu_percent(interval=0.5)
                    mem = proc.memory_info().rss / 1024 / 1024
                    cpu_samples.append(cpu)
                    mem_samples.append(mem)
                    
                    # Print status
                    avg_cpu = sum(cpu_samples) / len(cpu_samples)
                    avg_mem = sum(mem_samples) / len(mem_samples)
                    
                    status = "✅ GOOD" if cpu < 40 else "⚠️  HIGH" if cpu < 60 else "🚨 CRITICAL"
                    
                    print(f"\r{i+1}/{duration}s | CPU: {cpu:.1f}% (avg: {avg_cpu:.1f}%) | "
                          f"Mem: {mem:.0f}MB (avg: {avg_mem:.0f}MB) | {status}    ", end='')
                    
                    time.sleep(1)
                    break
            except:
                pass
    
    print("\n")
    
    if cpu_samples:
        avg_cpu = sum(cpu_samples) / len(cpu_samples)
        max_cpu = max(cpu_samples)
        avg_mem = sum(mem_samples) / len(mem_samples)
        
        print("📊 Performance Summary:")
        print(f"   Average CPU: {avg_cpu:.1f}%")
        print(f"   Peak CPU: {max_cpu:.1f}%")
        print(f"   Average Memory: {avg_mem:.0f}MB")
        
        if avg_cpu < 40:
            print("   ✅ CPU usage is now under control!")
        elif avg_cpu < 60:
            print("   ⚡ CPU usage reduced but still elevated")
        else:
            print("   🚨 CPU still high - consider disabling features")
    else:
        print("⚠️  Could not monitor performance")

def main():
    """Main emergency fix process"""
    print("\n🚨 Ironcliw EMERGENCY CPU FIX")
    print("="*50)
    print("This will reduce CPU usage from 97% to ~40%")
    print("")
    
    # Step 1: Kill high CPU processes
    killed = kill_high_cpu_processes()
    
    # Step 2: Apply configuration fixes
    apply_immediate_fixes()
    
    # Step 3: Patch the learning module
    patch_success = patch_learning_module()
    
    # Step 4: Restart with limits
    if killed > 0 or not patch_success:
        process = restart_with_limits()
    
    # Step 5: Monitor performance
    monitor_performance(30)
    
    print("\n" + "="*50)
    print("✅ Emergency CPU fix applied!")
    print("\n💡 For permanent fix, run:")
    print("   python migrate_to_rust_performance.py")
    print("\n📋 Current measures applied:")
    print("   • CPU throttling active")
    print("   • Thread limits: 2")
    print("   • Learning cycles throttled 5x")
    print("   • Skip cycles when CPU > 60%")
    print("="*50)

if __name__ == "__main__":
    main()