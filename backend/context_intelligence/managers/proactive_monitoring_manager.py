"""
Proactive Monitoring Manager
=============================

Autonomous monitoring and alerting system with:
- Continuous monitoring of critical spaces
- Automatic error detection and alerts
- Build/process completion detection
- Context-aware alert generation
- Dynamic priority based on user activity

Generates unprompted alerts like:
"Sir, a new error appeared in Space 3, line 422."
"Build completed in Space 5."
"""

import asyncio
import logging
import time
from typing import Dict, List, Optional, Any, Callable, Set
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

logger = logging.getLogger(__name__)


# ============================================================================
# DATA STRUCTURES
# ============================================================================

class AlertPriority(Enum):
    """Alert priority levels"""
    CRITICAL = "critical"  # Errors, failures
    HIGH = "high"         # Build completion, important state changes
    MEDIUM = "medium"     # Minor changes
    LOW = "low"          # Informational


class MonitoringEventType(Enum):
    """Types of monitoring events"""
    ERROR_DETECTED = "error_detected"
    ERROR_RESOLVED = "error_resolved"
    BUILD_STARTED = "build_started"
    BUILD_COMPLETED = "build_completed"
    BUILD_FAILED = "build_failed"
    PROCESS_STARTED = "process_started"
    PROCESS_COMPLETED = "process_completed"
    CONTENT_CHANGED = "content_changed"
    STATE_CHANGED = "state_changed"


@dataclass
class MonitoringAlert:
    """Alert generated by proactive monitoring"""
    event_type: MonitoringEventType
    priority: AlertPriority
    space_id: int
    message: str
    timestamp: float
    context: Dict[str, Any] = field(default_factory=dict)
    entity_id: Optional[str] = None


@dataclass
class MonitoredSpace:
    """Configuration for a monitored space"""
    space_id: int
    priority: AlertPriority
    check_interval: float  # Seconds between checks
    last_check: float = 0.0
    enabled: bool = True
    watch_for: Set[MonitoringEventType] = field(default_factory=set)


# ============================================================================
# PROACTIVE MONITORING MANAGER
# ============================================================================

class ProactiveMonitoringManager:
    """
    Autonomous monitoring system for detecting and alerting on state changes.

    Features:
    - Continuous monitoring of critical spaces
    - Event detection (errors, builds, processes)
    - Context-aware alert generation
    - Dynamic priority adjustment based on user activity
    - Async monitoring loop with configurable intervals
    """

    def __init__(
        self,
        change_detection_manager: Optional[Any] = None,
        capture_manager: Optional[Any] = None,
        ocr_manager: Optional[Any] = None,
        implicit_resolver: Optional[Any] = None,
        conversation_tracker: Optional[Any] = None,
        default_interval: float = 10.0,  # Check every 10 seconds
        alert_callback: Optional[Callable] = None
    ):
        """
        Initialize Proactive Monitoring Manager.

        Args:
            change_detection_manager: ChangeDetectionManager for detecting changes
            capture_manager: CaptureStrategyManager for screenshots
            ocr_manager: OCRStrategyManager for text extraction
            implicit_resolver: For understanding user context
            conversation_tracker: For tracking user activity
            default_interval: Default monitoring interval (seconds)
            alert_callback: Function to call when alert is generated
        """
        self.change_detection_manager = change_detection_manager
        self.capture_manager = capture_manager
        self.ocr_manager = ocr_manager
        self.implicit_resolver = implicit_resolver
        self.conversation_tracker = conversation_tracker
        self.default_interval = default_interval
        self.alert_callback = alert_callback

        # Monitored spaces
        self._monitored_spaces: Dict[int, MonitoredSpace] = {}
        self._monitoring_task: Optional[asyncio.Task] = None
        self._running = False

        # Alert history
        self._alert_history: List[MonitoringAlert] = []
        self._max_history = 100

        logger.info("[PROACTIVE-MONITOR] Initialized")
        logger.info(f"  Default Interval: {default_interval}s")
        logger.info(f"  Change Detection: {'âœ…' if change_detection_manager else 'âŒ'}")
        logger.info(f"  Capture Manager: {'âœ…' if capture_manager else 'âŒ'}")
        logger.info(f"  OCR Manager: {'âœ…' if ocr_manager else 'âŒ'}")
        logger.info(f"  Implicit Resolver: {'âœ…' if implicit_resolver else 'âŒ'}")
        logger.info(f"  Conversation Tracker: {'âœ…' if conversation_tracker else 'âŒ'}")

    def set_implicit_resolver(self, resolver) -> None:
        """v236.0: Late-bind implicit resolver (may not be available at init time).

        Follows the same pattern as TemporalQueryHandler.set_implicit_resolver().
        """
        self.implicit_resolver = resolver
        logger.info(
            f"[PROACTIVE-MONITOR] Implicit Resolver: "
            f"{'âœ…' if resolver else 'âŒ'} (late-bound)"
        )

    async def start_monitoring(self):
        """Start the autonomous monitoring loop"""
        if self._running:
            logger.warning("[PROACTIVE-MONITOR] Monitoring already running")
            return

        self._running = True
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())
        logger.info("[PROACTIVE-MONITOR] ðŸš€ Started monitoring")

    async def stop_monitoring(self):
        """Stop the monitoring loop"""
        if not self._running:
            return

        self._running = False
        if self._monitoring_task:
            self._monitoring_task.cancel()
            try:
                await self._monitoring_task
            except asyncio.CancelledError:
                pass

        logger.info("[PROACTIVE-MONITOR] â¹ï¸  Stopped monitoring")

    def add_space(
        self,
        space_id: int,
        priority: AlertPriority = AlertPriority.MEDIUM,
        check_interval: Optional[float] = None,
        watch_for: Optional[Set[MonitoringEventType]] = None
    ):
        """
        Add a space to monitoring.

        Args:
            space_id: Space to monitor
            priority: Alert priority for this space
            check_interval: Custom check interval (None = use default)
            watch_for: Event types to watch for (None = all)
        """
        if watch_for is None:
            watch_for = set(MonitoringEventType)

        self._monitored_spaces[space_id] = MonitoredSpace(
            space_id=space_id,
            priority=priority,
            check_interval=check_interval or self.default_interval,
            watch_for=watch_for
        )

        logger.info(f"[PROACTIVE-MONITOR] Added space {space_id} with priority {priority.value}")

    def remove_space(self, space_id: int):
        """Remove a space from monitoring"""
        if space_id in self._monitored_spaces:
            del self._monitored_spaces[space_id]
            logger.info(f"[PROACTIVE-MONITOR] Removed space {space_id} from monitoring")

    async def add_critical_spaces_from_context(self):
        """
        Automatically add critical spaces based on user's recent activity.
        Uses conversation tracker to determine which spaces user cares about.
        """
        if not self.conversation_tracker:
            return

        try:
            # Get recent conversation context
            context = self.conversation_tracker.get_recent_context(limit=10)

            # Extract space mentions
            space_mentions = {}
            for turn in context.get('turns', []):
                # Look for space references in user messages
                if turn.get('role') == 'user':
                    text = turn.get('text', '').lower()

                    # Extract space IDs mentioned
                    import re
                    space_refs = re.findall(r'space\s+(\d+)', text)
                    for space_id in space_refs:
                        space_id = int(space_id)
                        space_mentions[space_id] = space_mentions.get(space_id, 0) + 1

            # Add frequently mentioned spaces with higher priority
            for space_id, mention_count in space_mentions.items():
                if space_id not in self._monitored_spaces:
                    # More mentions = higher priority
                    if mention_count >= 3:
                        priority = AlertPriority.CRITICAL
                    elif mention_count >= 2:
                        priority = AlertPriority.HIGH
                    else:
                        priority = AlertPriority.MEDIUM

                    self.add_space(space_id, priority=priority)
                    logger.info(
                        f"[PROACTIVE-MONITOR] Auto-added space {space_id} "
                        f"(mentioned {mention_count} times, priority: {priority.value})"
                    )

        except Exception as e:
            logger.warning(f"[PROACTIVE-MONITOR] Could not add critical spaces: {e}")

    # ========================================================================
    # MONITORING LOOP
    # ========================================================================

    async def _monitoring_loop(self):
        """Main monitoring loop"""
        logger.info("[PROACTIVE-MONITOR] Monitoring loop started")

        while self._running:
            try:
                # Check each monitored space
                for space_id, config in list(self._monitored_spaces.items()):
                    if not config.enabled:
                        continue

                    # Check if it's time to check this space
                    now = time.time()
                    if now - config.last_check < config.check_interval:
                        continue

                    # Check the space
                    await self._check_space(space_id, config)
                    config.last_check = now

                # Sleep briefly before next iteration
                await asyncio.sleep(1.0)

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"[PROACTIVE-MONITOR] Error in monitoring loop: {e}")
                await asyncio.sleep(5.0)  # Back off on error

        logger.info("[PROACTIVE-MONITOR] Monitoring loop stopped")

    async def _check_space(self, space_id: int, config: MonitoredSpace):
        """Check a space for changes and generate alerts"""
        try:
            # Capture current state
            image, ocr_text = await self._capture_space_state(space_id)

            if not image and not ocr_text:
                return

            # Detect changes using ChangeDetectionManager
            if self.change_detection_manager:
                result = await self.change_detection_manager.detect_changes(
                    space_id=space_id,
                    current_image=image,
                    current_ocr_text=ocr_text
                )

                if result.changed:
                    # Analyze changes and generate alerts
                    alerts = await self._analyze_changes(space_id, config, result, ocr_text)

                    for alert in alerts:
                        await self._emit_alert(alert)

        except Exception as e:
            logger.error(f"[PROACTIVE-MONITOR] Error checking space {space_id}: {e}")

    async def _capture_space_state(self, space_id: int) -> tuple[Optional[Any], Optional[str]]:
        """Capture current state of a space"""
        image = None
        ocr_text = None

        try:
            # Capture screenshot
            if self.capture_manager:
                capture_result = await self.capture_manager.capture_with_fallback(
                    space_id=space_id,
                    max_attempts=2
                )
                if capture_result.success:
                    image = capture_result.image

                    # Run OCR
                    if self.ocr_manager and image:
                        ocr_result = await self.ocr_manager.ocr_with_fallback(
                            image=image,
                            max_attempts=1
                        )
                        if ocr_result.success:
                            ocr_text = ocr_result.text

        except Exception as e:
            logger.debug(f"[PROACTIVE-MONITOR] Could not capture space {space_id}: {e}")

        return image, ocr_text

    async def _analyze_changes(
        self,
        space_id: int,
        config: MonitoredSpace,
        change_result: Any,
        ocr_text: Optional[str]
    ) -> List[MonitoringAlert]:
        """Analyze changes and generate appropriate alerts"""
        alerts = []

        if not ocr_text:
            return alerts

        ocr_lower = ocr_text.lower()

        # Get previous snapshot for comparison
        previous = change_result.previous_snapshot
        previous_text = previous.ocr_text.lower() if previous and previous.ocr_text else ""

        # Detect errors
        if MonitoringEventType.ERROR_DETECTED in config.watch_for:
            error_alerts = self._detect_errors(
                space_id, config, ocr_text, ocr_lower, previous_text
            )
            alerts.extend(error_alerts)

        # Detect error resolutions
        if MonitoringEventType.ERROR_RESOLVED in config.watch_for:
            resolution_alerts = self._detect_error_resolutions(
                space_id, config, ocr_lower, previous_text
            )
            alerts.extend(resolution_alerts)

        # Detect build events
        if any(e in config.watch_for for e in [
            MonitoringEventType.BUILD_STARTED,
            MonitoringEventType.BUILD_COMPLETED,
            MonitoringEventType.BUILD_FAILED
        ]):
            build_alerts = self._detect_build_events(
                space_id, config, ocr_text, ocr_lower, previous_text
            )
            alerts.extend(build_alerts)

        # Detect process events
        if any(e in config.watch_for for e in [
            MonitoringEventType.PROCESS_STARTED,
            MonitoringEventType.PROCESS_COMPLETED
        ]):
            process_alerts = self._detect_process_events(
                space_id, config, ocr_lower, previous_text
            )
            alerts.extend(process_alerts)

        return alerts

    def _detect_errors(
        self,
        space_id: int,
        config: MonitoredSpace,
        ocr_text: str,
        ocr_lower: str,
        previous_text: str
    ) -> List[MonitoringAlert]:
        """Detect new errors"""
        alerts = []

        # Error patterns with line number extraction
        import re
        error_patterns = [
            (r'error[:\s]+([^\n]+?)(?:line[:\s]+(\d+))?', 'Error'),
            (r'exception[:\s]+([^\n]+?)(?:line[:\s]+(\d+))?', 'Exception'),
            (r'failed[:\s]+([^\n]+?)(?:line[:\s]+(\d+))?', 'Failed'),
            (r'traceback[:\s]*([^\n]+)', 'Traceback'),
        ]

        for pattern, error_type in error_patterns:
            matches = re.finditer(pattern, ocr_lower, re.IGNORECASE)

            for match in matches:
                error_text = match.group(1).strip()
                line_number = match.group(2) if len(match.groups()) > 1 else None

                # Check if this is a NEW error (not in previous text)
                if error_text not in previous_text:
                    message = f"Sir, a new {error_type.lower()} appeared in Space {space_id}"

                    if line_number:
                        message += f", line {line_number}"

                    message += f": {error_text[:100]}"

                    alerts.append(MonitoringAlert(
                        event_type=MonitoringEventType.ERROR_DETECTED,
                        priority=config.priority,
                        space_id=space_id,
                        message=message,
                        timestamp=time.time(),
                        context={
                            'error_type': error_type,
                            'error_text': error_text,
                            'line_number': line_number
                        },
                        entity_id=f"error_{error_text[:50]}"
                    ))

        return alerts

    def _detect_error_resolutions(
        self,
        space_id: int,
        config: MonitoredSpace,
        ocr_lower: str,
        previous_text: str
    ) -> List[MonitoringAlert]:
        """Detect resolved errors"""
        alerts = []

        # Check if previous text had errors but current doesn't
        if 'error' in previous_text and 'error' not in ocr_lower:
            alerts.append(MonitoringAlert(
                event_type=MonitoringEventType.ERROR_RESOLVED,
                priority=AlertPriority.HIGH,
                space_id=space_id,
                message=f"Good news, sir. The error in Space {space_id} appears to be resolved.",
                timestamp=time.time()
            ))

        return alerts

    def _detect_build_events(
        self,
        space_id: int,
        config: MonitoredSpace,
        ocr_text: str,
        ocr_lower: str,
        previous_text: str
    ) -> List[MonitoringAlert]:
        """Detect build-related events"""
        alerts = []

        # Build completion patterns
        completion_patterns = [
            'build succeeded',
            'build successful',
            'compilation succeeded',
            'build completed',
            'build: success'
        ]

        for pattern in completion_patterns:
            if pattern in ocr_lower and pattern not in previous_text:
                alerts.append(MonitoringAlert(
                    event_type=MonitoringEventType.BUILD_COMPLETED,
                    priority=AlertPriority.HIGH,
                    space_id=space_id,
                    message=f"Sir, the build has completed successfully in Space {space_id}.",
                    timestamp=time.time(),
                    entity_id="build"
                ))
                break

        # Build failure patterns
        failure_patterns = [
            'build failed',
            'build error',
            'compilation failed',
            'build: failed'
        ]

        for pattern in failure_patterns:
            if pattern in ocr_lower and pattern not in previous_text:
                alerts.append(MonitoringAlert(
                    event_type=MonitoringEventType.BUILD_FAILED,
                    priority=AlertPriority.CRITICAL,
                    space_id=space_id,
                    message=f"Sir, the build has failed in Space {space_id}.",
                    timestamp=time.time(),
                    entity_id="build"
                ))
                break

        # Build started
        start_patterns = [
            'build started',
            'building...',
            'compiling...'
        ]

        for pattern in start_patterns:
            if pattern in ocr_lower and pattern not in previous_text:
                if MonitoringEventType.BUILD_STARTED in config.watch_for:
                    alerts.append(MonitoringAlert(
                        event_type=MonitoringEventType.BUILD_STARTED,
                        priority=AlertPriority.MEDIUM,
                        space_id=space_id,
                        message=f"Build started in Space {space_id}.",
                        timestamp=time.time(),
                        entity_id="build"
                    ))
                break

        return alerts

    def _detect_process_events(
        self,
        space_id: int,
        config: MonitoredSpace,
        ocr_lower: str,
        previous_text: str
    ) -> List[MonitoringAlert]:
        """Detect process-related events"""
        alerts = []

        # Process completion
        if 'process completed' in ocr_lower and 'process completed' not in previous_text:
            alerts.append(MonitoringAlert(
                event_type=MonitoringEventType.PROCESS_COMPLETED,
                priority=AlertPriority.HIGH,
                space_id=space_id,
                message=f"Sir, the process in Space {space_id} has completed.",
                timestamp=time.time()
            ))

        return alerts

    async def _emit_alert(self, alert: MonitoringAlert):
        """Emit an alert"""
        # Add to history
        self._alert_history.append(alert)
        if len(self._alert_history) > self._max_history:
            self._alert_history.pop(0)

        # Log alert
        priority_emoji = {
            AlertPriority.CRITICAL: "ðŸš¨",
            AlertPriority.HIGH: "âš ï¸",
            AlertPriority.MEDIUM: "â„¹ï¸",
            AlertPriority.LOW: "ðŸ’¬"
        }

        emoji = priority_emoji.get(alert.priority, "ðŸ“¢")
        logger.info(f"[PROACTIVE-MONITOR] {emoji} {alert.message}")

        # Call alert callback if provided
        if self.alert_callback:
            try:
                if asyncio.iscoroutinefunction(self.alert_callback):
                    await self.alert_callback(alert)
                else:
                    self.alert_callback(alert)
            except Exception as e:
                logger.error(f"[PROACTIVE-MONITOR] Alert callback failed: {e}")

    def get_alert_history(self, limit: int = 10) -> List[MonitoringAlert]:
        """Get recent alerts"""
        return self._alert_history[-limit:]

    def get_monitoring_status(self) -> Dict[str, Any]:
        """Get current monitoring status"""
        return {
            'running': self._running,
            'monitored_spaces': len(self._monitored_spaces),
            'spaces': [
                {
                    'space_id': space.space_id,
                    'priority': space.priority.value,
                    'enabled': space.enabled,
                    'interval': space.check_interval
                }
                for space in self._monitored_spaces.values()
            ],
            'total_alerts': len(self._alert_history)
        }


# ============================================================================
# GLOBAL INSTANCE
# ============================================================================

_global_manager: Optional[ProactiveMonitoringManager] = None


def get_proactive_monitoring_manager() -> Optional[ProactiveMonitoringManager]:
    """Get the global proactive monitoring manager instance"""
    return _global_manager


def initialize_proactive_monitoring_manager(
    change_detection_manager: Optional[Any] = None,
    capture_manager: Optional[Any] = None,
    ocr_manager: Optional[Any] = None,
    implicit_resolver: Optional[Any] = None,
    conversation_tracker: Optional[Any] = None,
    default_interval: float = 10.0,
    alert_callback: Optional[Callable] = None
) -> ProactiveMonitoringManager:
    """
    Initialize the global ProactiveMonitoringManager instance.

    Args:
        change_detection_manager: ChangeDetectionManager instance
        capture_manager: CaptureStrategyManager instance
        ocr_manager: OCRStrategyManager instance
        implicit_resolver: ImplicitReferenceResolver instance
        conversation_tracker: ConversationTracker instance
        default_interval: Default monitoring interval (seconds)
        alert_callback: Function to call when alert is generated

    Returns:
        ProactiveMonitoringManager instance
    """
    global _global_manager

    _global_manager = ProactiveMonitoringManager(
        change_detection_manager=change_detection_manager,
        capture_manager=capture_manager,
        ocr_manager=ocr_manager,
        implicit_resolver=implicit_resolver,
        conversation_tracker=conversation_tracker,
        default_interval=default_interval,
        alert_callback=alert_callback
    )

    logger.info("[PROACTIVE-MONITOR] Global instance initialized")
    return _global_manager
