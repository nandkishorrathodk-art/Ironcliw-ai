<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JARVIS - System Initialization</title>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="alternate icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="theme-color" content="#0a0a12" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Matrix Color Palette */
            --matrix-green: #00ff41;
            --matrix-green-dim: #00aa2e;
            --matrix-dark-green: #003300;
            --cyber-cyan: #00d4ff;
            --cyber-cyan-dim: #0099bb;
            --cyber-teal: #00ffcc;
            --success-green: #00ff41;
            --panel-bg: rgba(10, 15, 25, 0.85);
            --panel-border: rgba(0, 212, 255, 0.3);
            --panel-border-bright: rgba(0, 212, 255, 0.6);
            --glow-cyan: rgba(0, 212, 255, 0.5);
            --glow-green: rgba(0, 255, 65, 0.4);
            --bg-dark: #0a0a12;
            --text-primary: #e0f7ff;
            --text-secondary: #7fdbff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg-dark);
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-primary);
        }

        /* Matrix Rain Canvas */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.7;
        }

        /* Glass Panel Container with 3D Perspective Tilt */
        .loading-container {
            position: relative;
            z-index: 10;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 20px;
            padding: 60px 80px;
            min-width: 580px;
            max-width: 680px;
            text-align: center;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            /* 3D perspective tilt effect matching target design */
            transform: perspective(1200px) rotateX(2deg) rotateY(-3deg);
            transform-style: preserve-3d;
            box-shadow:
                /* Main glow */
                0 0 40px rgba(0, 212, 255, 0.2),
                0 0 80px rgba(0, 212, 255, 0.1),
                /* Edge highlights for 3D effect */
                inset 2px 0 20px rgba(0, 212, 255, 0.15),
                inset -2px 0 20px rgba(0, 212, 255, 0.1),
                inset 0 2px 20px rgba(0, 212, 255, 0.15),
                inset 0 -2px 20px rgba(0, 212, 255, 0.1),
                /* Depth shadow */
                10px 15px 40px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.5s ease-out, border-color 0.5s ease-out, transform 0.5s ease-out;
        }

        /* Glowing edge accents on the panel */
        .loading-container::before {
            content: '';
            position: absolute;
            top: -1px;
            right: -1px;
            bottom: -1px;
            width: 3px;
            background: linear-gradient(180deg,
                transparent 10%,
                rgba(0, 212, 255, 0.6) 30%,
                rgba(0, 255, 204, 0.8) 50%,
                rgba(0, 212, 255, 0.6) 70%,
                transparent 90%);
            border-radius: 0 20px 20px 0;
            filter: blur(2px);
            pointer-events: none;
        }

        .loading-container::after {
            content: '';
            position: absolute;
            top: -1px;
            left: 10%;
            right: 10%;
            height: 2px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(0, 212, 255, 0.4) 30%,
                rgba(0, 255, 204, 0.6) 50%,
                rgba(0, 212, 255, 0.4) 70%,
                transparent 100%);
            filter: blur(1px);
            pointer-events: none;
        }

        /* Success state glow */
        .loading-container.success-state {
            border-color: var(--success-green);
            box-shadow:
                0 0 60px rgba(0, 255, 65, 0.4),
                0 0 120px rgba(0, 255, 65, 0.2),
                inset 0 0 60px rgba(0, 40, 20, 0.3);
        }

        /* Dynamic Title */
        .system-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 600;
            letter-spacing: 8px;
            color: var(--cyber-cyan);
            text-shadow:
                0 0 10px var(--cyber-cyan),
                0 0 20px var(--glow-cyan),
                0 0 40px var(--glow-cyan);
            margin-bottom: 40px;
            text-transform: uppercase;
            transition: color 0.3s ease-out, text-shadow 0.3s ease-out;
        }

        /* Success title state */
        .system-title.success-state {
            color: var(--success-green);
            text-shadow:
                0 0 10px var(--success-green),
                0 0 30px var(--success-green),
                0 0 60px var(--success-green);
        }

        /* Circular Progress Container - Larger to match target design */
        .progress-circle-container {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto 50px;
        }

        /* SVG Progress Circle */
        .progress-svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        /* Outer Decorative Ring - Mechanical Easing */
        .ring-outer-deco {
            fill: none;
            stroke: var(--panel-border);
            stroke-width: 1;
            stroke-dasharray: 8 4;
            animation: mechanicalRotateSlow 8s cubic-bezier(0.4, 0.0, 0.2, 1) infinite;
            transform-origin: center;
        }

        /* Middle Ring - Heavy Mechanical Easing (Addendum 2) */
        .ring-middle {
            fill: none;
            stroke: var(--cyber-cyan-dim);
            stroke-width: 2;
            opacity: 0.6;
            animation: mechanicalRotateReverse 5s cubic-bezier(0.25, 0.1, 0.25, 1.0) infinite;
            transform-origin: center;
        }

        /* Progress Track */
        .progress-track {
            fill: none;
            stroke: rgba(0, 212, 255, 0.15);
            stroke-width: 8;
            stroke-linecap: round;
        }

        /* Progress Arc - circumference = 2 * π * 100 = 628.32 */
        .progress-arc {
            fill: none;
            stroke: url(#progressGradient);
            stroke-width: 8;
            stroke-linecap: round;
            stroke-dasharray: 628.32;
            stroke-dashoffset: 628.32;
            transition: stroke-dashoffset 0.5s ease-out, stroke 0.3s ease-out;
            filter: url(#glowFilter);
        }

        /* Success state for progress arc */
        .progress-arc.success-state {
            stroke: var(--success-green);
            filter: url(#successGlowFilter);
        }

        /* Inner Glow Ring - Mechanical Easing */
        .ring-inner-glow {
            fill: none;
            stroke: var(--cyber-cyan);
            stroke-width: 1;
            opacity: 0.4;
            animation: mechanicalPulseGlow 4s cubic-bezier(0.4, 0.0, 0.6, 1) infinite;
        }

        /* Tech Segments on outer ring */
        .tech-segment {
            fill: var(--cyber-cyan);
            opacity: 0.8;
            transition: fill 0.3s ease-out;
        }

        .tech-segment.success-state {
            fill: var(--success-green);
        }

        /* Center Content */
        .progress-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .progress-percentage {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 700;
            color: var(--cyber-cyan);
            text-shadow:
                0 0 20px var(--glow-cyan),
                0 0 40px var(--glow-cyan);
            line-height: 1;
            transition: color 0.3s ease-out, text-shadow 0.3s ease-out;
        }

        /* Success state for percentage */
        .progress-percentage.success-state {
            color: var(--success-green);
            text-shadow:
                0 0 30px var(--success-green),
                0 0 60px var(--success-green);
        }

        /* Chromatic Aberration Effect (Addendum 3) */
        @keyframes chromaticAberration {
            0% {
                text-shadow:
                    -2px 0 rgba(255, 0, 0, 0.7),
                    2px 0 rgba(0, 100, 255, 0.7),
                    0 0 20px var(--glow-cyan);
                transform: translate(-50%, -50%) translateX(1px);
            }
            25% {
                text-shadow:
                    -3px 0 rgba(255, 0, 0, 0.5),
                    3px 0 rgba(0, 100, 255, 0.5),
                    0 0 20px var(--glow-cyan);
                transform: translate(-50%, -50%) translateX(-1px);
            }
            50% {
                text-shadow:
                    -1px 0 rgba(255, 0, 0, 0.3),
                    1px 0 rgba(0, 100, 255, 0.3),
                    0 0 20px var(--glow-cyan);
                transform: translate(-50%, -50%) translateX(0);
            }
            100% {
                text-shadow:
                    0 0 20px var(--glow-cyan),
                    0 0 40px var(--glow-cyan);
                transform: translate(-50%, -50%);
            }
        }

        .chromatic-glitch {
            animation: chromaticAberration 0.2s ease-out forwards;
        }

        /* Status message chromatic aberration */
        @keyframes statusChromaticAberration {
            0% {
                text-shadow:
                    -2px 0 rgba(255, 0, 0, 0.5),
                    2px 0 rgba(0, 100, 255, 0.5),
                    0 0 10px var(--glow-green);
                transform: translateX(1px);
            }
            50% {
                text-shadow:
                    -1px 0 rgba(255, 0, 0, 0.3),
                    1px 0 rgba(0, 100, 255, 0.3),
                    0 0 10px var(--glow-green);
                transform: translateX(-1px);
            }
            100% {
                text-shadow: 0 0 10px var(--glow-green);
                transform: translateX(0);
            }
        }

        .status-chromatic-glitch {
            animation: statusChromaticAberration 0.2s ease-out forwards;
        }

        #subtitle {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            letter-spacing: 2px;
            margin-top: 8px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        /* Hidden progress bar (for JS compatibility) */
        #progress-bar {
            display: none;
        }

        /* Status Message */
        .status-message {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.1rem;
            color: var(--cyber-teal);
            letter-spacing: 1px;
            text-shadow: 0 0 10px var(--glow-green);
            min-height: 1.5em;
            transition: color 0.3s ease-out, text-shadow 0.3s ease-out;
        }

        /* Success state for status message */
        .status-message.success-state {
            color: var(--success-green);
            text-shadow: 0 0 20px var(--success-green);
        }

        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0, 20, 30, 0.8);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            z-index: 100;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--matrix-green);
            box-shadow: 0 0 10px var(--matrix-green);
            animation: blink 1.5s ease-in-out infinite;
        }

        .status-indicator.connecting { background: #ffaa00; box-shadow: 0 0 10px #ffaa00; }
        .status-indicator.connected { background: var(--matrix-green); animation: none; }
        .status-indicator.disconnected { background: #ff4444; box-shadow: 0 0 10px #ff4444; }
        .status-indicator.starting { background: #ffaa00; }
        .status-indicator.loading { background: var(--cyber-cyan); }
        .status-indicator.initializing { background: var(--cyber-teal); }
        .status-indicator.verifying { background: var(--cyber-cyan); animation: blink 0.5s infinite; }
        .status-indicator.finalizing { background: var(--matrix-green); animation: blink 0.3s infinite; }
        .status-indicator.ready { background: var(--matrix-green); animation: none; box-shadow: 0 0 15px var(--matrix-green); }
        .status-indicator.error { background: #ff4444; animation: none; }

        #status-text {
            color: var(--text-secondary);
        }

        /* Circuit Board Decoration */
        .circuit-decoration {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 300px;
            height: 200px;
            opacity: 0.3;
            z-index: 5;
            pointer-events: none;
        }

        .circuit-line {
            stroke: var(--cyber-cyan);
            stroke-width: 1.5;
            fill: none;
            stroke-linecap: round;
        }

        .circuit-node {
            fill: var(--cyber-cyan);
        }

        .circuit-pulse {
            animation: circuitPulse 3s ease-in-out infinite;
        }

        /* Error Container */
        .error-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 0, 0, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .error-container.visible {
            display: flex;
        }

        .error-icon {
            font-size: 5rem;
            margin-bottom: 20px;
        }

        .error-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: #ff4444;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
            margin-bottom: 20px;
        }

        .error-message {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            color: #ff8888;
            max-width: 500px;
            text-align: center;
            line-height: 1.6;
        }

        /* Arc Reactor class for JS compatibility */
        .arc-reactor {
            position: relative;
        }

        /* Particles container for JS compatibility */
        #particles {
            display: none;
        }

        /* Animations - Addendum 2: Mechanical Easing */
        @keyframes mechanicalRotateSlow {
            0% { transform: rotate(0deg); }
            15% { transform: rotate(30deg); }
            50% { transform: rotate(180deg); }
            85% { transform: rotate(330deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes mechanicalRotateReverse {
            0% { transform: rotate(360deg); }
            10% { transform: rotate(324deg); }
            30% { transform: rotate(252deg); }
            70% { transform: rotate(108deg); }
            90% { transform: rotate(36deg); }
            100% { transform: rotate(0deg); }
        }

        @keyframes mechanicalPulseGlow {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            25% { opacity: 0.5; transform: scale(1.01); }
            50% { opacity: 0.7; transform: scale(1.02); }
            75% { opacity: 0.5; transform: scale(1.01); }
        }

        @keyframes rotateSlow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes rotateReverse {
            from { transform: rotate(360deg); }
            to { transform: rotate(0deg); }
        }

        @keyframes pulseGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        @keyframes textPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes circuitPulse {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.6; }
        }

        /* Success pulse animation */
        @keyframes successPulse {
            0%, 100% {
                box-shadow: 0 0 60px rgba(0, 255, 65, 0.4);
            }
            50% {
                box-shadow: 0 0 100px rgba(0, 255, 65, 0.7);
            }
        }

        .success-pulse {
            animation: successPulse 0.4s ease-in-out 2;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .loading-container {
                min-width: auto;
                width: 90%;
                padding: 30px 25px;
                margin: 20px;
            }

            .system-title {
                font-size: 1.3rem;
                letter-spacing: 4px;
            }

            .progress-circle-container {
                width: 200px;
                height: 200px;
            }

            .progress-percentage {
                font-size: 2.5rem;
            }

            .status-message {
                font-size: 0.9rem;
            }

            .circuit-decoration {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Canvas -->
    <canvas id="matrix-canvas"></canvas>

    <!-- Circuit Board Decoration -->
    <svg class="circuit-decoration" viewBox="0 0 300 200">
        <defs>
            <filter id="circuitGlow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
        <g filter="url(#circuitGlow)">
            <!-- Horizontal lines -->
            <path class="circuit-line circuit-pulse" d="M0 180 H80 L100 160 H150"/>
            <path class="circuit-line" d="M0 150 H50 L70 130 H120 L140 150 H180" style="animation-delay: 0.5s"/>
            <path class="circuit-line circuit-pulse" d="M0 120 H40 V100 H90 L110 80 H160" style="animation-delay: 1s"/>
            <path class="circuit-line" d="M0 80 H30 L50 60 H100 V40 H140" style="animation-delay: 1.5s"/>

            <!-- Vertical lines -->
            <path class="circuit-line circuit-pulse" d="M60 200 V160 L80 140 V100" style="animation-delay: 0.3s"/>
            <path class="circuit-line" d="M120 200 V170 L140 150 V110 L160 90" style="animation-delay: 0.8s"/>

            <!-- Nodes -->
            <circle class="circuit-node" cx="80" cy="180" r="3"/>
            <circle class="circuit-node" cx="100" cy="160" r="2"/>
            <circle class="circuit-node" cx="150" cy="160" r="3"/>
            <circle class="circuit-node" cx="50" cy="150" r="2"/>
            <circle class="circuit-node" cx="70" cy="130" r="3"/>
            <circle class="circuit-node" cx="180" cy="150" r="2"/>
            <circle class="circuit-node" cx="40" cy="120" r="2"/>
            <circle class="circuit-node" cx="90" cy="100" r="3"/>
            <circle class="circuit-node" cx="160" cy="80" r="2"/>
            <circle class="circuit-node" cx="50" cy="60" r="2"/>
            <circle class="circuit-node" cx="100" cy="40" r="3"/>
            <circle class="circuit-node" cx="140" cy="40" r="2"/>
            <circle class="circuit-node" cx="60" cy="160" r="2"/>
            <circle class="circuit-node" cx="80" cy="140" r="3"/>
            <circle class="circuit-node" cx="120" cy="170" r="2"/>
            <circle class="circuit-node" cx="160" cy="90" r="3"/>
        </g>
    </svg>

    <!-- Connection Status -->
    <div class="connection-status">
        <div class="status-indicator connecting" id="status-indicator"></div>
        <span id="status-text">Connecting...</span>
    </div>

    <!-- Main Loading Container -->
    <div class="loading-container" id="loading-container">
        <!-- Dynamic Title -->
        <h1 class="system-title" id="system-title">SYSTEM RESTART</h1>

        <!-- Circular Progress Indicator -->
        <div class="progress-circle-container arc-reactor">
            <svg class="progress-svg" viewBox="0 0 320 320">
                <defs>
                    <!-- Gradient for progress arc -->
                    <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00ffcc;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#00d4ff;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00ff88;stop-opacity:1" />
                    </linearGradient>
                    <!-- Success gradient -->
                    <linearGradient id="successGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00ff41;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00ff88;stop-opacity:1" />
                    </linearGradient>
                    <!-- Glow filter -->
                    <filter id="glowFilter" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                    <!-- Success glow filter (more intense) -->
                    <filter id="successGlowFilter" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="8" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>

                <!-- Outer Decorative Ring with tech segments -->
                <circle class="ring-outer-deco" cx="160" cy="160" r="155"/>

                <!-- Tech segment markers around outer ring -->
                <g id="tech-segments">
                    <rect class="tech-segment" x="157" y="2" width="6" height="14" rx="1"/>
                    <rect class="tech-segment" x="157" y="304" width="6" height="14" rx="1"/>
                    <rect class="tech-segment" x="2" y="157" width="14" height="6" rx="1"/>
                    <rect class="tech-segment" x="304" y="157" width="14" height="6" rx="1"/>
                    <!-- Diagonal markers -->
                    <rect class="tech-segment" x="268" y="48" width="8" height="4" rx="1" transform="rotate(45 272 50)"/>
                    <rect class="tech-segment" x="48" y="268" width="8" height="4" rx="1" transform="rotate(45 52 270)"/>
                    <rect class="tech-segment" x="48" y="48" width="8" height="4" rx="1" transform="rotate(-45 52 50)"/>
                    <rect class="tech-segment" x="268" y="268" width="8" height="4" rx="1" transform="rotate(-45 272 270)"/>
                </g>

                <!-- Middle Ring -->
                <circle class="ring-middle" cx="160" cy="160" r="130"/>

                <!-- Progress Track -->
                <circle class="progress-track" cx="160" cy="160" r="100"/>

                <!-- Progress Arc -->
                <circle class="progress-arc" id="progress-circle" cx="160" cy="160" r="100"/>

                <!-- Inner Glow Ring -->
                <circle class="ring-inner-glow" cx="160" cy="160" r="72"/>
            </svg>

            <!-- Center Content -->
            <div class="progress-center">
                <div class="progress-percentage" id="progress-percentage">0%</div>
                <div id="subtitle">INITIALIZING</div>
            </div>
        </div>

        <!-- Hidden progress bar for JS compatibility -->
        <div id="progress-bar" style="width: 0%;"></div>

        <!-- Status Message -->
        <div class="status-message" id="status-message">Initializing JARVIS systems...</div>
    </div>

    <!-- Error Container -->
    <div class="error-container" id="error-container">
        <div class="error-icon">⚠️</div>
        <div class="error-title">SYSTEM FAILURE</div>
        <div class="error-message" id="error-message">An error occurred during initialization.</div>
    </div>

    <!-- Hidden particles div for JS compatibility -->
    <div id="particles"></div>

    <!-- Matrix Rain Animation Script with Addendum 1: Realistic Depth & Glitch Effects -->
    <script>
        class MatrixRain {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.columns = [];
                this.fontSize = 14;
                this.characters = '01';
                this.brightLeaderChance = 0.20; // 20% of columns have bright cyan-white leaders
                this.glitchChance = 0.003; // Chance per character per frame to glitch
                this.init();
                this.animate();

                window.addEventListener('resize', () => this.init());
            }

            init() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                const columnCount = Math.floor(this.canvas.width / this.fontSize);
                this.columns = [];

                for (let i = 0; i < columnCount; i++) {
                    const hasBrightLeader = Math.random() < this.brightLeaderChance;
                    this.columns.push({
                        x: i * this.fontSize,
                        y: Math.random() * this.canvas.height,
                        speed: Math.random() * 2 + 1,
                        chars: [],
                        length: Math.floor(Math.random() * 15) + 5,
                        hasBrightLeader: hasBrightLeader,
                        glitchOffset: 0, // Horizontal glitch offset
                        glitchTimer: 0
                    });

                    // Initialize character array for this column
                    for (let j = 0; j < this.columns[i].length; j++) {
                        this.columns[i].chars.push({
                            char: this.getRandomChar(),
                            opacity: 1 - (j / this.columns[i].length),
                            glitching: false,
                            glitchX: 0
                        });
                    }
                }
            }

            getRandomChar() {
                return this.characters[Math.floor(Math.random() * this.characters.length)];
            }

            draw() {
                // Semi-transparent black to create trail effect
                this.ctx.fillStyle = 'rgba(10, 10, 18, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = `${this.fontSize}px 'Share Tech Mono', monospace`;

                for (let col of this.columns) {
                    // Update glitch state for column
                    if (col.glitchTimer > 0) {
                        col.glitchTimer--;
                        if (col.glitchTimer === 0) {
                            col.glitchOffset = 0;
                        }
                    } else if (Math.random() < 0.001) {
                        // Start a new glitch
                        col.glitchOffset = (Math.random() - 0.5) * 6;
                        col.glitchTimer = Math.floor(Math.random() * 3) + 1;
                    }

                    // Draw each character in the column
                    for (let i = 0; i < col.chars.length; i++) {
                        const y = col.y - (i * this.fontSize);

                        if (y < -this.fontSize * col.length) continue;
                        if (y > this.canvas.height + this.fontSize) continue;

                        // Calculate x position with potential glitch
                        let charGlitchX = 0;
                        if (Math.random() < this.glitchChance) {
                            col.chars[i].glitching = true;
                            col.chars[i].glitchX = (Math.random() - 0.5) * 4;
                        } else if (col.chars[i].glitching) {
                            col.chars[i].glitching = false;
                            col.chars[i].glitchX = 0;
                        }
                        charGlitchX = col.chars[i].glitchX + col.glitchOffset;

                        const drawX = col.x + charGlitchX;

                        // Addendum 1: Bright white-cyan leader for 20% of columns
                        if (i === 0) {
                            if (col.hasBrightLeader) {
                                // Bright white-cyan leader
                                this.ctx.fillStyle = '#e0ffff';
                                this.ctx.shadowBlur = 15;
                                this.ctx.shadowColor = '#00ffff';
                            } else {
                                // Standard bright white-green leader
                                this.ctx.fillStyle = '#ffffff';
                                this.ctx.shadowBlur = 10;
                                this.ctx.shadowColor = '#00ff41';
                            }
                        } else if (i === 1 && col.hasBrightLeader) {
                            // Second character also brighter for bright leader columns
                            const opacity = col.chars[i].opacity * 0.9;
                            this.ctx.fillStyle = `rgba(0, 255, 200, ${opacity})`;
                            this.ctx.shadowBlur = 5;
                            this.ctx.shadowColor = '#00ffcc';
                        } else {
                            const opacity = col.chars[i].opacity * 0.8;
                            this.ctx.fillStyle = `rgba(0, 255, 65, ${opacity})`;
                            this.ctx.shadowBlur = 0;
                        }

                        this.ctx.fillText(col.chars[i].char, drawX, y);

                        // Randomly change character
                        if (Math.random() < 0.02) {
                            col.chars[i].char = this.getRandomChar();
                        }
                    }

                    // Move column down
                    col.y += col.speed;

                    // Reset when off screen
                    if (col.y - (col.length * this.fontSize) > this.canvas.height) {
                        col.y = 0;
                        col.speed = Math.random() * 2 + 1;
                        col.length = Math.floor(Math.random() * 15) + 5;
                        col.hasBrightLeader = Math.random() < this.brightLeaderChance;
                        col.glitchOffset = 0;
                        col.glitchTimer = 0;

                        // Reset characters
                        col.chars = [];
                        for (let j = 0; j < col.length; j++) {
                            col.chars.push({
                                char: this.getRandomChar(),
                                opacity: 1 - (j / col.length),
                                glitching: false,
                                glitchX: 0
                            });
                        }
                    }
                }
            }

            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize Matrix Rain
        const matrixCanvas = document.getElementById('matrix-canvas');
        const matrixRain = new MatrixRain(matrixCanvas);

        // Progress circle animation helper
        function updateProgressCircle(percentage) {
            const circle = document.getElementById('progress-circle');
            if (circle) {
                const circumference = 2 * Math.PI * 100; // r = 100 (updated for larger circle)
                const offset = circumference - (percentage / 100) * circumference;
                circle.style.strokeDashoffset = offset;
            }
        }

        // Addendum 3: Chromatic Aberration Effect on data updates
        function triggerChromaticGlitch(element, isPercentage = false) {
            if (!element) return;

            // Remove existing animation class
            element.classList.remove('chromatic-glitch', 'status-chromatic-glitch');

            // Force reflow to restart animation
            void element.offsetWidth;

            // Add appropriate animation class
            if (isPercentage) {
                element.classList.add('chromatic-glitch');
            } else {
                element.classList.add('status-chromatic-glitch');
            }

            // Remove class after animation completes
            setTimeout(() => {
                element.classList.remove('chromatic-glitch', 'status-chromatic-glitch');
            }, 200);
        }

        // Addendum 4: Success State Transition Sequence
        let successStateTriggered = false;

        function triggerSuccessState() {
            if (successStateTriggered) return Promise.resolve();
            successStateTriggered = true;

            return new Promise((resolve) => {
                const container = document.getElementById('loading-container');
                const title = document.getElementById('system-title');
                const percentage = document.getElementById('progress-percentage');
                const statusMessage = document.getElementById('status-message');
                const progressCircle = document.getElementById('progress-circle');
                const techSegments = document.querySelectorAll('.tech-segment');

                // Instant color change to success green
                container.classList.add('success-state', 'success-pulse');
                title.classList.add('success-state');
                title.textContent = 'ACCESS GRANTED';
                percentage.classList.add('success-state');
                statusMessage.classList.add('success-state');
                statusMessage.textContent = 'System Ready - Redirecting...';
                progressCircle.classList.add('success-state');
                progressCircle.style.stroke = '#00ff41';

                // Update tech segments
                techSegments.forEach(seg => seg.classList.add('success-state'));

                // Trigger intense chromatic glitch on title
                triggerChromaticGlitch(percentage, true);

                // Hold for 800ms then resolve
                setTimeout(() => {
                    resolve();
                }, 800);
            });
        }

        // Update title based on URL or startup type
        function updateDynamicTitle() {
            const title = document.getElementById('system-title');
            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode');

            if (mode === 'restart' || window.location.href.includes('restart')) {
                title.textContent = 'SYSTEM RESTART';
            } else if (mode === 'init' || mode === 'fresh') {
                title.textContent = 'SYSTEM INITIALIZATION';
            } else {
                // Default - check subtitle for context
                title.textContent = 'SYSTEM STARTUP';
            }
        }

        // Track last values to detect changes
        let lastPercentageValue = '';
        let lastStatusMessage = '';

        // Hook into the loading manager's progress updates
        const progressPercentageEl = document.getElementById('progress-percentage');
        const statusMessageEl = document.getElementById('status-message');

        // Create a MutationObserver to watch for style changes on progress-bar
        const progressBar = document.getElementById('progress-bar');
        if (progressBar) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                        const width = progressBar.style.width;
                        if (width) {
                            const percentage = parseFloat(width);
                            if (!isNaN(percentage)) {
                                updateProgressCircle(percentage);
                            }
                        }
                    }
                });
            });

            observer.observe(progressBar, { attributes: true });
        }

        // Watch the percentage text element for direct updates
        if (progressPercentageEl) {
            const textObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList' || mutation.type === 'characterData') {
                        const text = progressPercentageEl.textContent;

                        // Trigger chromatic aberration on change
                        if (text !== lastPercentageValue) {
                            triggerChromaticGlitch(progressPercentageEl, true);
                            lastPercentageValue = text;
                        }

                        const match = text.match(/(\d+)/);
                        if (match) {
                            const percentage = parseInt(match[1]);
                            updateProgressCircle(percentage);

                            // Check for 100% completion
                            if (percentage >= 100 && !successStateTriggered) {
                                triggerSuccessState();
                            }
                        }
                    }
                });
            });

            textObserver.observe(progressPercentageEl, {
                childList: true,
                characterData: true,
                subtree: true
            });
        }

        // Watch status message for changes
        if (statusMessageEl) {
            const statusObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList' || mutation.type === 'characterData') {
                        const text = statusMessageEl.textContent;

                        // Trigger chromatic aberration on change
                        if (text !== lastStatusMessage) {
                            triggerChromaticGlitch(statusMessageEl, false);
                            lastStatusMessage = text;
                        }
                    }
                });
            });

            statusObserver.observe(statusMessageEl, {
                childList: true,
                characterData: true,
                subtree: true
            });
        }

        // Expose success state function globally for loading-manager.js
        window.triggerSuccessState = triggerSuccessState;
        window.successStateTriggered = () => successStateTriggered;

        // Initialize
        updateDynamicTitle();
    </script>

    <!-- Loading Manager Script -->
    <script src="/loading-manager.js"></script>
</body>
</html>
